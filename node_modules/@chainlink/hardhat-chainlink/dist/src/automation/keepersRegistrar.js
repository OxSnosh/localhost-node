"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getKeepersRegistrarTypeAndVersion = exports.getKeepersRegistrarConfig = exports.cancelKeepersPendingRegistrationRequest = exports.getKeepersPendingRegistrationRequest = exports.registerUpkeep = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const keeperRegistrar_abi_json_1 = __importDefault(require("../abis/keeperRegistrar.abi.json"));
const linkToken_abi_json_1 = __importDefault(require("../abis/linkToken.abi.json"));
const registerUpkeep = async (env, linkTokenAddress, keepersRegistrarAddress, amountInJuels, name, encryptedEmail, upkeepContract, gasLimit, adminAddress, checkData, source, sender, waitNumberOfConfirmations) => {
    const [signer] = await env.ethers.getSigners();
    const linkToken = new ethers_1.Contract(linkTokenAddress, linkToken_abi_json_1.default, signer);
    const solidityRegisterFunctionSignature = `register`;
    const KeeperRegistrarInterface = new utils_1.Interface(keeperRegistrar_abi_json_1.default);
    const functionSelector = KeeperRegistrarInterface.getSighash(solidityRegisterFunctionSignature);
    const tx = await linkToken.transferAndCall(keepersRegistrarAddress, amountInJuels, utils_1.defaultAbiCoder.encode([
        "bytes4",
        "string",
        "bytes",
        "address",
        "uint32",
        "address",
        "bytes",
        "uint96",
        "uint8",
        "address",
    ], [
        functionSelector,
        name,
        encryptedEmail,
        upkeepContract,
        gasLimit,
        adminAddress,
        checkData,
        amountInJuels,
        source,
        sender,
    ]));
    await tx.wait(waitNumberOfConfirmations);
    return { transactionHash: tx.hash };
};
exports.registerUpkeep = registerUpkeep;
const getKeepersPendingRegistrationRequest = async (env, keepersRegistrarAddress, hash) => {
    const [signer] = await env.ethers.getSigners();
    const keepersRegistrar = new ethers_1.Contract(keepersRegistrarAddress, keeperRegistrar_abi_json_1.default, signer);
    const pendingRequest = await keepersRegistrar.getPendingRequest(hash);
    return { adminAddress: pendingRequest[0], balance: pendingRequest[1] };
};
exports.getKeepersPendingRegistrationRequest = getKeepersPendingRegistrationRequest;
const cancelKeepersPendingRegistrationRequest = async (env, keepersRegistrarAddress, hash, waitNumberOfConfirmations) => {
    const [signer] = await env.ethers.getSigners();
    const keepersRegistrar = new ethers_1.Contract(keepersRegistrarAddress, keeperRegistrar_abi_json_1.default, signer);
    const tx = await keepersRegistrar.cancel(hash);
    await tx.wait(waitNumberOfConfirmations);
    return { transactionHash: tx.hash };
};
exports.cancelKeepersPendingRegistrationRequest = cancelKeepersPendingRegistrationRequest;
const getKeepersRegistrarConfig = async (env, keepersRegistrarAddress) => {
    const [signer] = await env.ethers.getSigners();
    const keepersRegistrar = new ethers_1.Contract(keepersRegistrarAddress, keeperRegistrar_abi_json_1.default, signer);
    const config = await keepersRegistrar.getRegistrationConfig();
    return {
        autoApproveConfigType: config.autoApproveConfigType,
        autoApproveMaxAllowed: config.autoApproveMaxAllowed,
        approvedCount: config.approvedCount,
        automationRegistry: config.keeperRegistry,
        minLINKJuels: config.minLINKJuels,
    };
};
exports.getKeepersRegistrarConfig = getKeepersRegistrarConfig;
const getKeepersRegistrarTypeAndVersion = async (env, keepersRegistrarAddress) => {
    const [signer] = await env.ethers.getSigners();
    const keepersRegistrar = new ethers_1.Contract(keepersRegistrarAddress, keeperRegistrar_abi_json_1.default, signer);
    return await keepersRegistrar.typeAndVersion();
};
exports.getKeepersRegistrarTypeAndVersion = getKeepersRegistrarTypeAndVersion;
//# sourceMappingURL=keepersRegistrar.js.map